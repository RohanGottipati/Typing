import { useState, useEffect, useCallback, useRef } from 'react';
import { Card, CardContent } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { TypingArea } from './TypingArea';
import { TestConfig } from './TestConfig';
import { paragraphRotator } from '@/lib/textData';
import { generateText, generateExactWordCount, processExistingText, TextGeneratorOptions } from '@/lib/textGenerator';
import { exportToCSV, exportToJSON } from '@/lib/exportUtils';
import { calculateBehavioralMetrics } from '@/lib/behavioralMetrics';
import { analyzeTypingPersona, getPersonaInsights } from '@/lib/typingPersonas';
import { generateResultsSummary } from '@/lib/resultsSummary';
import { saveSession, getSessions } from '@/lib/sessionStorage';
import { getRandomQuote } from '@/lib/quotesData';
import { SessionHistory } from './SessionHistory';
import { ErrorAnalysis } from './ErrorAnalysis';
import { BehavioralInsights } from './BehavioralInsights';
import { calculateHistoricalAverages, getCurrentSessionData } from '@/lib/insightsUtils';
import { WPMPrediction } from './WPMPrediction';
import { wpmPredictor } from '@/lib/wpmPredictor';
import { AnalyticsDashboard } from './AnalyticsDashboard';
import { normalizeToKeyId } from '@/lib/keyboardHeatmap';



export interface TestSettings {
  duration: number;
  textType: 'sentences' | 'quotes' | 'code';
  mode: 'time' | 'words' | 'quote' | 'zen' | 'custom';
  punctuation: boolean;
  numbers: boolean;
  wordCount?: number;
  customText?: string;
  customUseTime?: boolean;
  customUseWords?: boolean;
  customTimeLimit?: number;
  customWordLimit?: number;
}

export interface KeystrokeData {
  key: string;
  keyId: string; // Standard key ID (e.g., 'KeyA', 'Digit1', 'Semicolon')
  correct: boolean;
  timestamp: number;
  position: number;
  latency?: number; // Time since last keystroke in ms
}

export interface WordStats {
  correctChars: number;
  totalChars: number;
  timeToComplete: number;
}

export const TypingTest = () => {
  // View state
  const [currentView, setCurrentView] = useState<'main' | 'analytics'>('main');
  
  // Test state
  const [testSettings, setTestSettings] = useState<TestSettings>({ 
    duration: 30, 
    textType: 'sentences',
    mode: 'time',
    punctuation: true,
    numbers: true,
    wordCount: 25,
    customText: '',
    customUseTime: false,
    customUseWords: false,
    customTimeLimit: 30,
    customWordLimit: 25
  });
  const [isTestActive, setIsTestActive] = useState(false);
  const [expectedText, setExpectedText] = useState('');
  const [currentPosition, setCurrentPosition] = useState(0);
  const [typedCharacters, setTypedCharacters] = useState<string[]>([]);
  const [characterStatus, setCharacterStatus] = useState<('correct' | 'incorrect' | '')[]>([]);
  
  // Timer state
  const [timeRemaining, setTimeRemaining] = useState(0);
  const [testStartTime, setTestStartTime] = useState<number | null>(null);
  const [countdown, setCountdown] = useState<number | null>(null);
  const [isCountingDown, setIsCountingDown] = useState(false);
  
  // Statistics
  const [correctCharacters, setCorrectCharacters] = useState(0);
  const [totalTypedCharacters, setTotalTypedCharacters] = useState(0);
  const [backspaces, setBackspaces] = useState(0);
  const [missedCharacters, setMissedCharacters] = useState<{ [key: string]: number }>({});
  const [wordsCompleted, setWordsCompleted] = useState(0);
  const [quoteAuthor, setQuoteAuthor] = useState('');
  const [isQuoteComplete, setIsQuoteComplete] = useState(false);
  const [liveWPM, setLiveWPM] = useState(0);
  const [firstKeystrokeTime, setFirstKeystrokeTime] = useState<number | null>(null);
  
  // NEW: Analytics tracking variables with unique names
  const [analytics_testStartMs, setAnalytics_testStartMs] = useState<number | null>(null);
  const [analytics_tickInterval, setAnalytics_tickInterval] = useState<NodeJS.Timeout | null>(null);
  const [analytics_wpmTimeline, setAnalytics_wpmTimeline] = useState<Array<{ second: number, wpm: number }>>([]);
  const [analytics_wpmTimelineSmoothed, setAnalytics_wpmTimelineSmoothed] = useState<Array<{ second: number, wpm: number }>>([]);
  const [analytics_correctCharsSoFar, setAnalytics_correctCharsSoFar] = useState(0);
  const [analytics_lastSecondProcessed, setAnalytics_lastSecondProcessed] = useState(0);
  const [analytics_errorsBySecond, setAnalytics_errorsBySecond] = useState<{ [key: number]: number }>({});
  const [analytics_backspacesBySecond, setAnalytics_backspacesBySecond] = useState<{ [key: number]: number }>({});
  
  // Results state
  const [showResults, setShowResults] = useState(false);
  const [finalWPM, setFinalWPM] = useState(0);
  const [finalAccuracy, setFinalAccuracy] = useState(0);
  const [behavioralMetrics, setBehavioralMetrics] = useState<{
    typingConsistencyScore: number;
    fatigueScore: number;
    reactionDelay: number;
    topErrorHotspots: { second: number; count: number }[];
    topBackspaceHotspots: { second: number; count: number }[];
  }>({
    typingConsistencyScore: 0,
    fatigueScore: 0,
    reactionDelay: 0,
    topErrorHotspots: [],
    topBackspaceHotspots: []
  });
  const [typingPersona, setTypingPersona] = useState<any>(null);
  const [personaInsights, setPersonaInsights] = useState<string[]>([]);
  const [peakErrorSecond, setPeakErrorSecond] = useState<string>('N/A');
  const [peakCorrectionSecond, setPeakCorrectionSecond] = useState<string>('N/A');
  
  // NEW: Words mode tracking variables with unique names
  const [words_targetTokens, setWords_targetTokens] = useState<string[]>([]);
  const [words_currentIndex, setWords_currentIndex] = useState(0);
  const [words_completedCount, setWords_completedCount] = useState(0);
  const [words_currentTyped, setWords_currentTyped] = useState('');
  const [words_perWordStats, setWords_perWordStats] = useState<{ [key: number]: WordStats }>({});
  const [words_modeActive, setWords_modeActive] = useState(false);
  const [words_autoEndTriggered, setWords_autoEndTriggered] = useState(false);
  const [words_autoEnded, setWords_autoEnded] = useState(false);
  
  // NEW: Text streaming for TIME mode
  const [textStream_position, setTextStream_position] = useState(0);
  const [textStream_buffer, setTextStream_buffer] = useState<string[]>([]);
  const [textStream_currentText, setTextStream_currentText] = useState('');
  
  // NEW: Zen mode state
  const [zen_modeActive, setZen_modeActive] = useState(false);
  const [zen_manualEndRequested, setZen_manualEndRequested] = useState(false);
  const [zenContent, setZenContent] = useState('');
  
  // NEW: Custom mode state
  const [custom_modeActive, setCustom_modeActive] = useState(false);
  const [custom_hasTimer, setCustom_hasTimer] = useState(false);
  const [custom_hasWordLimit, setCustom_hasWordLimit] = useState(false);
  
  // Historical session state
  const [selectedSession, setSelectedSession] = useState<any>(null);
  const [showHistoricalResults, setShowHistoricalResults] = useState(false);
  
  // Keystroke tracking
  const [keystrokeLog, setKeystrokeLog] = useState<KeystrokeData[]>([]);
  
  // Refs for cleanup
  const timerRef = useRef<NodeJS.Timeout | null>(null);

  const testEndedRef = useRef(false);
  const endTestRef = useRef<(() => void) | null>(null);

  // Get next paragraph with punctuation/numbers toggles
  const getNextParagraph = useCallback(() => {
    console.log('ðŸ“ getNextParagraph called with settings:', {
      textType: testSettings.textType,
      mode: testSettings.mode,
      customText: testSettings.customText
    });
    
    // For quotes, use the original text without modification
    if (testSettings.textType === 'quotes') {
      console.log('ðŸ“ Using quotes text type');
      const paragraph = paragraphRotator.getNextParagraph(testSettings.textType);
      console.log('ðŸ“ Retrieved quote paragraph:', paragraph);
      return paragraph;
    }
    
    // For custom mode with user-provided text, use as-is
    if (testSettings.mode === 'custom' && testSettings.customText) {
      console.log('ðŸ“ Using custom text:', testSettings.customText);
      return {
        id: 'custom-text',
        category: 'sentences',
        text: testSettings.customText
      };
    }
    
    // For other modes, generate new text based on toggles
    const options: TextGeneratorOptions = {
      includeNumbers: testSettings.numbers,
      includePunctuation: testSettings.punctuation,
      streaming: testSettings.mode === 'time'
    };
    
    console.log('ðŸ“ Generating text with options:', options);
    
    let generatedText: string;
    
    if (testSettings.mode === 'words' && testSettings.wordCount) {
      // Generate exactly N words for Words mode
      console.log('ðŸ“ Generating exact word count:', testSettings.wordCount);
      generatedText = generateExactWordCount(testSettings.wordCount, options);
    } else {
      // Generate text for other modes
      console.log('ðŸ“ Generating regular text');
      generatedText = generateText(options);
    }
    
    console.log('ðŸ“ Text generation result:', { 
      generated: generatedText, 
      length: generatedText?.length || 0,
      punctuation: testSettings.punctuation, 
      numbers: testSettings.numbers,
      mode: testSettings.mode
    });
    
    // Guard against empty text
    if (!generatedText || generatedText.trim().length === 0) {
      console.warn('âš ï¸ getNextParagraph: Generated text is empty, using fallback');
      generatedText = 'The quick brown fox jumps over the lazy dog. This is a fallback text.';
    }
    
    return {
      id: 'generated-text',
      category: 'sentences',
      text: generatedText
    };
  }, [testSettings.textType, testSettings.punctuation, testSettings.numbers, testSettings.mode, testSettings.wordCount, testSettings.customText]);

  // NEW: Parse text into words for Words mode
  const parseTextIntoWords = useCallback((text: string): string[] => {
    // Split by word boundaries: space, newline, tab, or end-of-text
    // Handle multiple consecutive spaces as one delimiter
    const words = text.trim().split(/\s+/);
    
    // Filter out empty strings and handle edge cases
    const filteredWords = words.filter(word => word.length > 0);
    
    console.log('ðŸ” Word parsing:', { 
      originalText: text, 
      splitWords: words, 
      filteredWords: filteredWords 
    });
    
    return filteredWords;
  }, []);

  // NEW: Check if character is a word delimiter
  const isWordDelimiter = useCallback((char: string): boolean => {
    return char === ' ' || char === '\n' || char === '\t' || char === '\r';
  }, []);

  // NEW: Check if character is punctuation that follows a word
  const isPunctuationAfterWord = useCallback((char: string): boolean => {
    return /[.,!?;:]/.test(char);
  }, []);

  // NEW: Generate sentence with exactly N words for Words mode
  const generateSentenceWithNWords = useCallback((wordCount: number): string => {
    const options: TextGeneratorOptions = {
      includeNumbers: testSettings.numbers,
      includePunctuation: testSettings.punctuation,
      targetWordCount: wordCount
    };
    
    const sentence = generateExactWordCount(wordCount, options);
    
    console.log('ðŸŽ¯ Generated sentence with', wordCount, 'words:', sentence);
    
    return sentence;
  }, [testSettings.punctuation, testSettings.numbers]);

  // NEW: Analytics WPM tracking functions
  const analytics_startWpmTracking = useCallback(() => {
    const startMs = Date.now();
    setAnalytics_testStartMs(startMs);
    setAnalytics_wpmTimeline([]);
    setAnalytics_wpmTimelineSmoothed([]);
    setAnalytics_correctCharsSoFar(0);
    setAnalytics_lastSecondProcessed(0);
    setAnalytics_errorsBySecond({});
    setAnalytics_backspacesBySecond({});
    
    console.log('ðŸš€ Analytics WPM tracking started at:', startMs);
    
    // Start the tick interval for WPM tracking
    const interval = setInterval(() => {
      const nowMs = Date.now();
      const elapsedSeconds = Math.floor((nowMs - startMs) / 1000);
      
      if (elapsedSeconds === 0) {
        console.log('â­ï¸ Skipping second 0 to avoid divide-by-zero');
        return;
      }
      
      if (elapsedSeconds > analytics_lastSecondProcessed) {
        const wpm = (analytics_correctCharsSoFar / 5) / (elapsedSeconds / 60);
        const roundedWpm = Math.round(wpm * 10) / 10; // Round to 1 decimal
        
        console.log(`ðŸ“Š Second ${elapsedSeconds}: ${analytics_correctCharsSoFar} chars, ${roundedWpm} WPM`);
        
        setAnalytics_wpmTimeline(prev => [...prev, { second: elapsedSeconds, wpm: roundedWpm }]);
        setAnalytics_lastSecondProcessed(elapsedSeconds);
      }
    }, 1000);
    
    setAnalytics_tickInterval(interval);
  }, [analytics_correctCharsSoFar, analytics_lastSecondProcessed]);
  
  const analytics_stopWpmTracking = useCallback(() => {
    if (analytics_tickInterval) {
      clearInterval(analytics_tickInterval);
      setAnalytics_tickInterval(null);
      console.log('ðŸ›‘ Analytics WPM tracking stopped');
    }
  }, [analytics_tickInterval]);
  
  const analytics_computeSmoothedTimeline = useCallback(() => {
    if (analytics_wpmTimeline.length < 3) {
      setAnalytics_wpmTimelineSmoothed(analytics_wpmTimeline);
      return;
    }
    
    const smoothed: Array<{ second: number, wpm: number }> = [];
    
    for (let i = 0; i < analytics_wpmTimeline.length; i++) {
      const start = Math.max(0, i - 1);
      const end = Math.min(analytics_wpmTimeline.length - 1, i + 1);
      const window = analytics_wpmTimeline.slice(start, end + 1);
      const avgWpm = window.reduce((sum, point) => sum + point.wpm, 0) / window.length;
      
      smoothed.push({
        second: analytics_wpmTimeline[i].second,
        wpm: Math.round(avgWpm * 10) / 10
      });
    }
    
    setAnalytics_wpmTimelineSmoothed(smoothed);
    console.log('ðŸ“ˆ Smoothed WPM timeline computed:', smoothed.length, 'points');
  }, [analytics_wpmTimeline]);
  
  const analytics_calculatePeakSeconds = useCallback(() => {
    // Calculate peak error second
    let peakErrorSecond = 'N/A';
    let maxErrors = 0;
    
    Object.entries(analytics_errorsBySecond).forEach(([second, count]) => {
      const secondNum = parseInt(second);
      if (secondNum === 0) return; // Skip second 0 unless there are genuine events
      if (count > maxErrors) {
        maxErrors = count;
        peakErrorSecond = second;
      }
    });
    
    if (maxErrors === 0) {
      peakErrorSecond = 'N/A';
    }
    
    // Calculate peak correction second
    let peakCorrectionSecond = 'N/A';
    let maxBackspaces = 0;
    
    Object.entries(analytics_backspacesBySecond).forEach(([second, count]) => {
      const secondNum = parseInt(second);
      if (secondNum === 0) return; // Skip second 0 unless there are genuine events
      if (count > maxBackspaces) {
        maxBackspaces = count;
        peakCorrectionSecond = second;
      }
    });
    
    if (maxBackspaces === 0) {
      peakCorrectionSecond = 'N/A';
    }
    
    console.log('ðŸŽ¯ Peak seconds calculated:', { peakErrorSecond, peakCorrectionSecond });
    
    return { peakErrorSecond, peakCorrectionSecond };
  }, [analytics_errorsBySecond, analytics_backspacesBySecond]);

  // NEW: Text streaming for TIME mode
  const textStream_extendText = useCallback(() => {
    if (testSettings.mode !== 'time') return;
    
    const newParagraph = getNextParagraph();
    const newText = newParagraph.text;
    
    console.log('ðŸ“– Text streaming: Extending with new paragraph:', newText);
    
    setTextStream_buffer(prev => [...prev, newText]);
    setTextStream_currentText(prev => prev + ' ' + newText);
    
    // Extend the expected text array
    setExpectedText(prev => prev + ' ' + newText);
    
    // Extend typed characters and character status arrays
    setTypedCharacters(prev => [...prev, ...new Array(newText.length + 1).fill('')]);
    setCharacterStatus(prev => [...prev, ...new Array(newText.length + 1).fill('')]);
    
    console.log('ðŸ“– Text streaming: Extended text length:', expectedText.length + newText.length + 1);
  }, [testSettings.mode, getNextParagraph, expectedText.length]);

  // NEW: Words mode completion logic with auto-end
  const words_onChar = useCallback((char: string) => {
    // Defensive checks
    if (!words_modeActive || !words_targetTokens || words_targetTokens.length === 0) {
      console.log('âš ï¸ Words mode: Not active or no target tokens available');
      return;
    }
    
    // Guard against double execution
    if (words_autoEndTriggered || words_autoEnded) {
      console.log('ðŸš« Words mode: Auto-end already triggered or completed, ignoring input');
      return;
    }
    
    if (words_currentIndex >= words_targetTokens.length) {
      console.log('âš ï¸ Words mode: Attempted to type beyond target tokens');
      return;
    }

    const currentTargetWord = words_targetTokens[words_currentIndex];
    if (!currentTargetWord) {
      console.log('âš ï¸ Words mode: No current target word');
      return;
    }

    const newTyped = words_currentTyped + char;
    
    console.log(`ðŸ”¤ Words mode: Typed "${char}", current buffer: "${newTyped}", target: "${currentTargetWord}", length: ${newTyped.length}/${currentTargetWord.length}`);
    
    setWords_currentTyped(newTyped);
    
    // Check if the last character of the current target word was typed
    // A word is completed when the LAST LETTER is typed, even if punctuation follows
    const isWordCompleted = newTyped.length >= currentTargetWord.length;
    console.log(`ðŸ” Words mode: Word completion check - Typed: ${newTyped.length}, Target: ${currentTargetWord.length}, Completed: ${isWordCompleted}`);
    
    if (isWordCompleted) {
      const completedWord = newTyped.slice(0, currentTargetWord.length);
      
      // Count the word whether it was typed correctly or incorrectly
      console.log(`âœ… Words mode: Word ${words_currentIndex + 1} completed! Target: "${currentTargetWord}", Typed: "${completedWord}"`);
      
      // Calculate word stats
      const correctChars = completedWord.split('').filter((c, i) => c === currentTargetWord[i]).length;
      const totalChars = completedWord.length;
      const timeToComplete = testStartTime ? (Date.now() - testStartTime) / 1000 : 0;
      
      const wordStats: WordStats = {
        correctChars,
        totalChars,
        timeToComplete
      };
      
      console.log(`ðŸ“Š Words mode: Word ${words_currentIndex + 1} stats:`, wordStats);
      
      // Store word stats
      setWords_perWordStats(prev => ({
        ...prev,
        [words_currentIndex]: wordStats
      }));
      
      // Increment completed count
      const newCompletedCount = words_completedCount + 1;
      setWords_completedCount(newCompletedCount);
      setWordsCompleted(newCompletedCount);
      
      console.log(`ðŸŽ¯ Words mode: Completed ${newCompletedCount}/${words_targetTokens.length} words`);
      
      // Log the moment of counting for verification
      console.log(`ðŸ” Words mode: COUNT VERIFICATION - Index: ${words_currentIndex}, Typed: "${completedWord}", New Count: ${newCompletedCount}`);
      
      // AUTO-END: Check if all words are completed (this is the Nth word)
      if (newCompletedCount >= words_targetTokens.length) {
        console.log('ðŸ Words mode: AUTO-END triggered! All words completed!');
        
        // Set guard to prevent double execution
        setWords_autoEndTriggered(true);
        setWords_autoEnded(true);
        
        // a) Freeze input immediately
        setWords_modeActive(false);
        
        // b) Stop any intervals/timers
        if (analytics_tickInterval) {
          clearInterval(analytics_tickInterval);
          setAnalytics_tickInterval(null);
        }
        
        // c) Build results and end test immediately
        if (endTestRef.current) {
          console.log('ðŸš€ Words mode: Calling endTest pipeline...');
          // Use setTimeout to ensure state updates are processed first
          setTimeout(() => {
            endTestRef.current!();
          }, 0);
        }
        return;
      }
      
      // Advance to next word
      setWords_currentIndex(prev => prev + 1);
      setWords_currentTyped('');
      
      console.log(`âž¡ï¸ Words mode: Advanced to word ${words_currentIndex + 2}/${words_targetTokens.length}`);
    }
  }, [words_modeActive, words_currentIndex, words_targetTokens, words_currentTyped, words_completedCount, testStartTime, endTestRef, analytics_tickInterval, words_autoEndTriggered, words_autoEnded, setWords_currentTyped, setWords_perWordStats, setWords_completedCount, setWordsCompleted, setWords_currentIndex, setWords_modeActive, setAnalytics_tickInterval, setWords_autoEndTriggered, setWords_autoEnded]);

  // Start test - Simplified and reliable
  const startTest = useCallback(() => {
    console.log('ðŸš€ Starting test with mode:', testSettings.mode);
    
    // Reset ALL state to prevent deadlocks
    setShowResults(false);
    setShowHistoricalResults(false);
    setSelectedSession(null);
    testEndedRef.current = false;
    
    // Reset mode-specific state
    setZen_modeActive(false);
    setZen_manualEndRequested(false);
    setZenContent('');
    setCustom_modeActive(false);
    setCustom_hasTimer(false);
    setCustom_hasWordLimit(false);
    setWords_modeActive(false);
    setWords_autoEndTriggered(false);
    setWords_autoEnded(false);
    
    let textToType = '';
    let author = '';
    
    // Generate text immediately for each mode
    switch (testSettings.mode) {
      case 'time':
        const timeParagraph = getNextParagraph();
        textToType = timeParagraph.text;
        console.log('â° TIME mode: Generated text length:', textToType.length);
        break;
        
      case 'words':
        const wordCount = testSettings.wordCount || 25;
        textToType = generateSentenceWithNWords(wordCount);
        const targetTokens = parseTextIntoWords(textToType);
        setWords_targetTokens(targetTokens);
        setWords_modeActive(true);
        console.log('ðŸ“ WORDS mode: Generated', wordCount, 'words, length:', textToType.length);
        break;
        
      case 'quote':
        const quote = getRandomQuote();
        textToType = quote.text;
        author = quote.author;
        setQuoteAuthor(author);
        setIsQuoteComplete(false);
        console.log('ðŸ’¬ QUOTE mode: Quote length:', textToType.length);
        break;
        
      case 'zen':
        textToType = ''; // Empty for zen mode
        setZen_modeActive(true);
        console.log('ðŸ§˜ ZEN mode: Empty text area');
        break;
        
      case 'custom':
        textToType = testSettings.customText || 'Type your custom text here...';
        setCustom_modeActive(true);
        setCustom_hasTimer(testSettings.customUseTime || false);
        setCustom_hasWordLimit(testSettings.customUseWords || false);
        console.log('âš™ï¸ CUSTOM mode: Custom text length:', textToType.length);
        break;
        
      default:
        const paragraph = getNextParagraph();
        textToType = paragraph.text;
        console.log('ðŸ“„ DEFAULT mode: Generated text length:', textToType.length);
        break;
    }
    
    // Set text and initialize state
    setExpectedText(textToType);
    setCurrentPosition(0);
    setTypedCharacters(new Array(textToType.length).fill(''));
    setCharacterStatus(new Array(textToType.length).fill(''));
    
    // Reset statistics
    setCorrectCharacters(0);
    setTotalTypedCharacters(0);
    setBackspaces(0);
    setMissedCharacters({});
    setWordsCompleted(0);
    setLiveWPM(0);
    setFirstKeystrokeTime(null);
    
    // Set timer based on mode
    if (testSettings.mode === 'time') {
      setTimeRemaining(testSettings.duration);
      console.log('â° Timer set to:', testSettings.duration, 'seconds');
    } else if (testSettings.mode === 'custom' && testSettings.customUseTime) {
      setTimeRemaining(testSettings.customTimeLimit || 30);
      console.log('â° Custom timer set to:', testSettings.customTimeLimit || 30, 'seconds');
    } else {
      setTimeRemaining(0);
      console.log('â° No timer for this mode');
    }
    
    // Reset analytics
    setAnalytics_testStartMs(null);
    setAnalytics_wpmTimeline([]);
    setAnalytics_wpmTimelineSmoothed([]);
    setAnalytics_correctCharsSoFar(0);
    setAnalytics_lastSecondProcessed(0);
    setAnalytics_errorsBySecond({});
    setAnalytics_backspacesBySecond({});
    
    // Reset behavioral metrics
    setBehavioralMetrics({
      typingConsistencyScore: 0,
      fatigueScore: 0,
      reactionDelay: 0,
      topErrorHotspots: [],
      topBackspaceHotspots: []
    });
    
    // Reset persona
    setTypingPersona(null);
    setPersonaInsights([]);
    
    // Clear keystroke log
    setKeystrokeLog([]);
    
    // Activate test
    setTestStartTime(null);
    setIsTestActive(true);
    
    console.log('âœ… Test started successfully. Text length:', textToType.length);
    
    // Start countdown only for TIME mode
    if (testSettings.mode === 'time') {
      setIsCountingDown(true);
      setCountdown(3);
      
      const countdownInterval = setInterval(() => {
        setCountdown(prev => {
          if (prev === null || prev <= 1) {
            clearInterval(countdownInterval);
            setIsCountingDown(false);
            setCountdown(null);
            const startTime = Date.now();
            setTestStartTime(startTime);
            
            let timeLeft = testSettings.duration;
            
            // Start analytics WPM tracking
            analytics_startWpmTracking();
            
            timerRef.current = setInterval(() => {
              timeLeft--;
              setTimeRemaining(timeLeft);
              
              // Update live WPM for zen mode using analytics data
              if (testSettings.mode === 'zen' && analytics_wpmTimeline.length > 0) {
                const latestWpm = analytics_wpmTimeline[analytics_wpmTimeline.length - 1].wpm;
                setLiveWPM(latestWpm);
              }

              if (timeLeft <= 0) {
                clearInterval(timerRef.current!);
                timerRef.current = null;
                if (endTestRef.current) {
                  endTestRef.current();
                }
              }
            }, 1000);
            
            return null;
          }
          return prev - 1;
        });
      }, 1000);
    } else {
      // For non-TIME modes, start immediately without countdown
      const startTime = Date.now();
      setTestStartTime(startTime);
      
      // Start analytics WPM tracking
      analytics_startWpmTracking();
      
      // Start timer for CUSTOM mode with timer
      if (testSettings.mode === 'custom' && testSettings.customUseTime) {
        let timeLeft = testSettings.customTimeLimit || 30;
        
        timerRef.current = setInterval(() => {
          timeLeft--;
          setTimeRemaining(timeLeft);
          
          if (timeLeft <= 0) {
            clearInterval(timerRef.current!);
            timerRef.current = null;
            if (endTestRef.current) {
              endTestRef.current();
            }
          }
        }, 1000);
      }
    }
  }, [testSettings, getNextParagraph, generateSentenceWithNWords, parseTextIntoWords, analytics_startWpmTracking, endTestRef]);

  // NEW: Manual end function for ZEN mode
  const handleZenManualEnd = useCallback(() => {
    if (testSettings.mode === 'zen' && isTestActive) {
      console.log('â–² ZEN mode: Manual end requested');
      setZen_manualEndRequested(true);
      if (endTestRef.current) {
        endTestRef.current();
      }
    }
  }, [testSettings.mode, isTestActive, endTestRef]);

  // End test
  const endTest = useCallback(() => {
    try {
      console.log("ðŸ”„ Test ending - starting cleanup and calculations...");
      
      if (testEndedRef.current) return;
      testEndedRef.current = true;

      // Stop analytics WPM tracking
      analytics_stopWpmTracking();
      
      if (timerRef.current) {
        clearInterval(timerRef.current);
        timerRef.current = null;
      }

      const endTime = Date.now();
      const testDurationMs = testStartTime ? endTime - testStartTime : testSettings.duration * 1000;
      const testDurationMinutes = testDurationMs / 60000;
      
      const finalWPMValue = testDurationMinutes > 0 ? (correctCharacters / 5) / testDurationMinutes : 0;
      const finalAccuracyValue = totalTypedCharacters > 0 ? (correctCharacters / totalTypedCharacters) * 100 : 0;
      
      console.log("ðŸ“Š Calculated final values:", { finalWPMValue, finalAccuracyValue, correctCharacters, totalTypedCharacters });
      
      // Calculate reaction delay
      const reactionDelay = firstKeystrokeTime && testStartTime ? 
        ((firstKeystrokeTime - testStartTime) / 1000) : 0;
      
      // Compute smoothed timeline and peak seconds
      analytics_computeSmoothedTimeline();
      const { peakErrorSecond: calculatedPeakErrorSecond, peakCorrectionSecond: calculatedPeakCorrectionSecond } = analytics_calculatePeakSeconds();
      
      // Set peak second values
      setPeakErrorSecond(calculatedPeakErrorSecond);
      setPeakCorrectionSecond(calculatedPeakCorrectionSecond);
      
      // Calculate behavioral metrics with safe defaults
      const wpmHistoryArray = analytics_wpmTimeline?.map(item => item.wpm) || [];
      console.log("ðŸ“ˆ Analytics WPM Timeline:", analytics_wpmTimeline);
      console.log("ðŸ“Š WPM History Array:", wpmHistoryArray);
      console.log("ðŸŽ¯ Peak seconds:", { peakErrorSecond: calculatedPeakErrorSecond, peakCorrectionSecond: calculatedPeakCorrectionSecond });
      
      const metrics = calculateBehavioralMetrics(keystrokeLog, wpmHistoryArray, testSettings.duration, reactionDelay);
      setBehavioralMetrics(metrics);
      
      // Calculate typing persona
      const personaData = {
        finalWPM: finalWPMValue,
        accuracy: finalAccuracyValue,
        consistencyScore: metrics.typingConsistencyScore,
        fatigueScore: metrics.fatigueScore,
        backspaceCount: backspaces,
        reactionDelay: metrics.reactionDelay,
        wpmOverTime: wpmHistoryArray
      };
      
      const persona = analyzeTypingPersona(personaData);
      const insights = getPersonaInsights(persona, personaData);
      setTypingPersona(persona);
      setPersonaInsights(insights);
      
      setFinalWPM(Math.round(finalWPMValue));
      setFinalAccuracy(parseFloat(finalAccuracyValue.toFixed(2)));
      
      console.log("âœ… All calculations complete, setting showResults to true");
      
      // Show results for all modes except zen (unless manually ended)
      if (testSettings.mode !== 'zen' || zen_manualEndRequested) {
        setShowResults(true);
        console.log('ðŸ“Š Results view activated for mode:', testSettings.mode);
      }
      
      setIsTestActive(false);
      
      // Save session with new analytics data
      saveSession(
        finalWPMValue,
        finalAccuracyValue,
        persona.name,
        backspaces,
        totalTypedCharacters,
        correctCharacters,
        totalTypedCharacters - correctCharacters,
        testSettings.duration,
        testSettings.textType,
        wpmHistoryArray,
        metrics.typingConsistencyScore,
        metrics.fatigueScore,
        metrics.reactionDelay,
        metrics.topErrorHotspots,
        metrics.topBackspaceHotspots,
        missedCharacters,
        insights
      );
      
      // Trigger WPM prediction update after saving session
      setTimeout(() => {
        try {
          const sessions = getSessions();
          const newPrediction = wpmPredictor.predictNextSessionWPM(sessions);
          console.log('ðŸ”® WPM Prediction updated after session save:', newPrediction);
          
          // Dispatch custom event to notify WPM prediction component
          window.dispatchEvent(new CustomEvent('sessionSaved'));
        } catch (error) {
          console.error('âŒ Error updating WPM prediction after session save:', error);
        }
      }, 100);
      
      console.log("ðŸŽ‰ Test ended successfully!");
    } catch (error) {
      console.error("âŒ Error in endTest function:", error);
      // Set safe defaults and show results anyway
      setFinalWPM(0);
      setFinalAccuracy(0);
      setBehavioralMetrics({
        typingConsistencyScore: 50,
        fatigueScore: 0,
        reactionDelay: 0,
        topErrorHotspots: [],
        topBackspaceHotspots: []
      });
      setTypingPersona(null);
      setPersonaInsights([]);
      setShowResults(true);
      setIsTestActive(false);
    }
  }, [testStartTime, testSettings.duration, correctCharacters, totalTypedCharacters, backspaces, analytics_wpmTimeline, keystrokeLog, firstKeystrokeTime, analytics_stopWpmTracking, analytics_computeSmoothedTimeline, analytics_calculatePeakSeconds]);

  // Store the endTest function in a ref
  endTestRef.current = endTest;

  // Handle keystroke
  const handleKeystroke = useCallback((key: string) => {
    if (!isTestActive || isCountingDown) {
      return;
    }
    
    // For ZEN mode, let the textarea handle typing
    if (testSettings.mode === 'zen') {
      return; // Let the textarea onChange handle Zen mode typing
    }
    
    // For other modes, check position limits
    if (currentPosition >= expectedText.length) {
      return;
    }
    
    // NEW: Prevent input after words mode completion
    if (words_modeActive && (words_completedCount >= words_targetTokens.length || words_autoEndTriggered || words_autoEnded)) {
      console.log('ðŸš« Words mode: Test completed, ignoring input');
      return;
    }
    
    // NEW: Prevent input after quote mode completion
    if (testSettings.mode === 'quote' && isQuoteComplete) {
      console.log('ðŸš« Quote mode: Test completed, ignoring input');
      return;
    }
    
    // NEW: Prevent input after custom mode completion
    if (testSettings.mode === 'custom' && custom_hasWordLimit && words_modeActive && words_completedCount >= (testSettings.customWordLimit || 25)) {
      console.log('ðŸš« Custom mode: Word limit reached, ignoring input');
      return;
    }
    
    // Track first keystroke time for reaction delay calculation
    if (firstKeystrokeTime === null && testStartTime) {
      setFirstKeystrokeTime(Date.now());
    }
    
    const expected = expectedText[currentPosition];
    const isCorrect = key === expected;
    const timestamp = testStartTime ? (Date.now() - testStartTime) / 1000 : 0;
    
    const lastKeystrokeTime = keystrokeLog.length > 0 ? keystrokeLog[keystrokeLog.length - 1].timestamp : 0;
    const latency = lastKeystrokeTime > 0 ? (timestamp - lastKeystrokeTime) * 1000 : 0; // Convert to ms
    
    const keystrokeData: KeystrokeData = {
      key,
      keyId: normalizeToKeyId(key),
      correct: isCorrect,
      timestamp,
      position: currentPosition,
      latency
    };
    
    setKeystrokeLog(prev => [...prev, keystrokeData]);
    
    setCharacterStatus(prev => {
      const newStatus = [...prev];
      newStatus[currentPosition] = isCorrect ? 'correct' : 'incorrect';
      return newStatus;
    });
    
    setTypedCharacters(prev => {
      const newTyped = [...prev];
      newTyped[currentPosition] = key;
      return newTyped;
    });
    
    if (isCorrect) {
      setCorrectCharacters(prev => prev + 1);
      
      // Update analytics correct characters count
      setAnalytics_correctCharsSoFar(prev => prev + 1);
      
      // Track correct characters per second for analytics
      if (analytics_testStartMs) {
        const elapsedSeconds = Math.floor((Date.now() - analytics_testStartMs) / 1000);
        console.log(`Correct character typed in second ${elapsedSeconds}, total so far: ${analytics_correctCharsSoFar + 1}`);
      }
    } else {
      setMissedCharacters(prev => ({
        ...prev,
        [expected]: (prev[expected] || 0) + 1
      }));
      
      // Track error by second for analytics
      if (analytics_testStartMs) {
        const elapsedSeconds = Math.floor((Date.now() - analytics_testStartMs) / 1000);
        setAnalytics_errorsBySecond(prev => ({
          ...prev,
          [elapsedSeconds]: (prev[elapsedSeconds] || 0) + 1
        }));
      }
    }
    
    setTotalTypedCharacters(prev => prev + 1);
    setCurrentPosition(prev => prev + 1);
    
    // NEW: Handle Words mode character input
    if (words_modeActive) {
      words_onChar(key);
    }
    
    // NEW: Handle text streaming for TIME mode
    if (testSettings.mode === 'time' && currentPosition >= expectedText.length - 50) {
      // Extend text when user is within 50 characters of the end
      textStream_extendText();
    }
    
    // Check for quote completion
    if (testSettings.mode === 'quote' && currentPosition >= expectedText.length && !isQuoteComplete) {
      console.log('ðŸ Quote mode: AUTO-END triggered! Quote completed!');
      setIsQuoteComplete(true);
      // End test when quote is completed
      if (endTestRef.current) {
        endTestRef.current();
      }
    }
    
    // NEW: Handle CUSTOM mode word limit completion
    if (testSettings.mode === 'custom' && custom_hasWordLimit && words_modeActive && words_completedCount >= (testSettings.customWordLimit || 25)) {
      console.log('ðŸ› ï¸ CUSTOM mode: Word limit reached, ending test');
      if (endTestRef.current) {
        endTestRef.current();
      }
    }
  }, [isTestActive, currentPosition, expectedText, testStartTime, testSettings, correctCharacters, firstKeystrokeTime, analytics_testStartMs, analytics_correctCharsSoFar, words_onChar, words_modeActive, words_completedCount, words_targetTokens, words_autoEndTriggered, words_autoEnded, textStream_extendText, custom_hasWordLimit, custom_hasTimer]);

  // Handle backspace
  const handleBackspace = useCallback(() => {
    if (!isTestActive || currentPosition === 0) {
      return;
    }
    
    setBackspaces(prev => prev + 1);
    
    // Track backspace by second for analytics
    if (analytics_testStartMs) {
      const elapsedSeconds = Math.floor((Date.now() - analytics_testStartMs) / 1000);
      setAnalytics_backspacesBySecond(prev => ({
        ...prev,
        [elapsedSeconds]: (prev[elapsedSeconds] || 0) + 1
      }));
    }
    
    const previousChar = typedCharacters[currentPosition - 1];
    const expectedChar = expectedText[currentPosition - 1];
    const wasCorrect = previousChar === expectedChar;
    
    setCharacterStatus(prev => {
      const newStatus = [...prev];
      newStatus[currentPosition - 1] = '';
      return newStatus;
    });
    
    setTypedCharacters(prev => {
      const newTyped = [...prev];
      newTyped[currentPosition - 1] = '';
      return newTyped;
    });
    
    if (wasCorrect) {
      setCorrectCharacters(prev => prev - 1);
      // Update analytics correct characters count
      setAnalytics_correctCharsSoFar(prev => prev - 1);
    }
    
    setTotalTypedCharacters(prev => prev - 1);
    setCurrentPosition(prev => prev - 1);
    
    // NEW: Handle Words mode backspace
    if (words_modeActive) {
      // Only handle backspace if we haven't completed the current word yet
      if (words_currentTyped.length > 0) {
        setWords_currentTyped(prev => prev.slice(0, -1));
        console.log(`âŒ« Words mode: Backspace, current buffer: "${words_currentTyped.slice(0, -1)}"`);
      }
    }
    
    // NEW: Handle Zen mode backspace
    if (testSettings.mode === 'zen') {
      // Let the textarea handle backspace naturally
      return;
    }
  }, [isTestActive, currentPosition, typedCharacters, expectedText, analytics_testStartMs, words_modeActive, words_currentTyped]);

  // Handle Zen content changes
  const handleZenContentChange = useCallback((content: string) => {
    if (!isTestActive || testSettings.mode !== 'zen') return;
    
    // Track first keystroke time for reaction delay calculation
    if (firstKeystrokeTime === null && testStartTime) {
      setFirstKeystrokeTime(Date.now());
    }
    
    const previousContent = zenContent;
    const newChar = content.length > previousContent.length ? content[content.length - 1] : null;
    
    setZenContent(content);
    
    // Track keystroke for analytics if a new character was added
    if (newChar && testStartTime) {
      const timestamp = (Date.now() - testStartTime) / 1000;
      const lastKeystrokeTime = keystrokeLog.length > 0 ? keystrokeLog[keystrokeLog.length - 1].timestamp : 0;
      const latency = lastKeystrokeTime > 0 ? (timestamp - lastKeystrokeTime) * 1000 : 0;
      
      const keystrokeData: KeystrokeData = {
        key: newChar,
        keyId: normalizeToKeyId(newChar),
        correct: true, // In ZEN mode, all keystrokes are considered correct
        timestamp,
        position: content.length - 1,
        latency
      };
      
      setKeystrokeLog(prev => [...prev, keystrokeData]);
      setCorrectCharacters(prev => prev + 1);
      setTotalTypedCharacters(prev => prev + 1);
      setAnalytics_correctCharsSoFar(prev => prev + 1);
    }
  }, [isTestActive, testSettings.mode, firstKeystrokeTime, testStartTime, zenContent, keystrokeLog]);

  // Live WPM update for Zen mode
  useEffect(() => {
    if (!isTestActive || testSettings.mode !== 'zen' || !testStartTime) return;
    
    const interval = setInterval(() => {
      if (zenContent.length > 0) {
        const elapsedMinutes = (Date.now() - testStartTime) / 60000;
        const wordCount = zenContent.trim().split(/\s+/).length;
        const wpm = elapsedMinutes > 0 ? wordCount / elapsedMinutes : 0;
        setLiveWPM(wpm);
      }
    }, 1000); // Update every second
    
    return () => clearInterval(interval);
  }, [isTestActive, testSettings.mode, testStartTime, zenContent]);

  // Handle key events
  const handleKeyDown = useCallback((e: React.KeyboardEvent) => {
    if (!isTestActive) return;
    
    // For Zen mode, let the textarea handle all key events naturally
    if (testSettings.mode === 'zen') {
      return;
    }
    
    e.preventDefault();
    
    if (e.key === 'Backspace') {
      handleBackspace();
    } else if (e.key.length === 1) {
      handleKeystroke(e.key);
    }
  }, [isTestActive, testSettings.mode, handleBackspace, handleKeystroke]);

  // Display historical session results
  const displayHistoricalResults = (session: any) => {
    setSelectedSession(session);
    setShowHistoricalResults(true);
    // Remove this line to prevent duplicate results display
    // setShowResults(true);
    
    // Set all the metrics from the historical session
    setFinalWPM(session.wpm);
    setFinalAccuracy(session.accuracy);
    setBackspaces(session.backspaces);
    // Set analytics timeline from historical data
    const historicalTimeline = session.wpmHistory ? session.wpmHistory.map((wpm: number, index: number) => ({ second: index + 1, wpm })) : [];
    setAnalytics_wpmTimeline(historicalTimeline);
    setAnalytics_wpmTimelineSmoothed(historicalTimeline); // Use same data for smoothed version
    setBehavioralMetrics({
      typingConsistencyScore: session.consistencyScore,
      fatigueScore: 0, // Remove fatigue score entirely
      reactionDelay: session.reactionDelay,
      topErrorHotspots: session.topErrorHotspots,
      topBackspaceHotspots: session.topBackspaceHotspots
    });
    setTypingPersona({
      name: session.personaType,
      title: session.personaType,
      description: "Historical typing persona",
      icon: "ðŸ“Š",
      traits: []
    });
    setPersonaInsights(session.personaInsights);
    
    // Set peak second values from historical data (if available)
    // Note: Historical sessions may not have this data, so we'll calculate it from hotspots
    if (session.topErrorHotspots && session.topErrorHotspots.length > 0) {
      const validErrorHotspots = session.topErrorHotspots.filter(spot => spot.second > 0);
      setPeakErrorSecond(validErrorHotspots.length > 0 ? validErrorHotspots[0].second.toString() : 'N/A');
    } else {
      setPeakErrorSecond('N/A');
    }
    
    if (session.topBackspaceHotspots && session.topBackspaceHotspots.length > 0) {
      const validBackspaceHotspots = session.topBackspaceHotspots.filter(spot => spot.second > 0);
      setPeakCorrectionSecond(validBackspaceHotspots.length > 0 ? validBackspaceHotspots[0].second.toString() : 'N/A');
    } else {
      setPeakCorrectionSecond('N/A');
    }
  };

  // Clear historical results
  const clearHistoricalResults = () => {
    setSelectedSession(null);
    setShowHistoricalResults(false);
    setShowResults(false);
  };

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (timerRef.current) clearInterval(timerRef.current);
  
    };
  }, []);

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 via-blue-900 to-green-900 p-4">
        <div className="max-w-4xl mx-auto space-y-6">
          {/* Header */}
          <div className="text-center space-y-4 fade-in">
            <h1 
              className="text-3xl font-bold text-cyan-100 cursor-pointer hover:text-cyan-200 transition-all duration-200 btn-hover"
              onClick={() => {
                // Reset to home state
                setCurrentView('main');
                setIsTestActive(false);
                setShowResults(false);
                setShowHistoricalResults(false);
                setSelectedSession(null);
                // Clear any active test state
                setTimeRemaining(30);
                setIsCountingDown(false);
                setCountdown(3);
                setCurrentPosition(0);
                setTypedCharacters([]);
                setCharacterStatus([]);
                setCorrectCharacters(0);
                setTotalTypedCharacters(0);
                setBackspaces(0);
                setMissedCharacters({});
                setExpectedText('');
                setTestStartTime(null);
                setFirstKeystrokeTime(null);
                setLiveWPM(0);
                setFinalWPM(0);
                setFinalAccuracy(0);
                setAnalytics_wpmTimeline([]);
                setAnalytics_wpmTimelineSmoothed([]);
                setAnalytics_errorsBySecond({});
                setAnalytics_backspacesBySecond({});
                setAnalytics_testStartMs(null);
                setAnalytics_tickInterval(null);
                setAnalytics_correctCharsSoFar(0);
                setAnalytics_lastSecondProcessed(0);
                setBehavioralMetrics({
                  typingConsistencyScore: 0,
                  fatigueScore: 0,
                  reactionDelay: 0,
                  topErrorHotspots: [],
                  topBackspaceHotspots: []
                });
                setTypingPersona(null);
                setPersonaInsights([]);
                setQuoteAuthor('');
                setIsQuoteComplete(false);
                setZenContent('');
                setZen_modeActive(false);
                setZen_manualEndRequested(false);
                setWords_modeActive(false);
                setWords_targetTokens([]);
                setWords_currentIndex(0);
                setWords_completedCount(0);
                setWords_currentTyped('');
                setWords_perWordStats({});
                setWords_autoEndTriggered(false);
                setWords_autoEnded(false);
                setTextStream_position(0);
                setTextStream_buffer([]);
                setTextStream_currentText('');
                setCustom_modeActive(false);
                setCustom_hasTimer(false);
                setCustom_hasWordLimit(false);
                setKeystrokeLog([]);
              }}
              title="Click to return to home"
            >
              Typora
            </h1>
            <p className="text-green-200 fade-in stagger-1">Test your typing speed and accuracy</p>
        
            {/* Navigation */}
            <div className="flex justify-center space-x-4">
              <Button
                onClick={() => setCurrentView('main')}
                variant={currentView === 'main' ? 'default' : 'outline'}
                className={`btn-hover btn-active transition-all duration-200 ${
                  currentView === 'main'
                    ? 'bg-cyan-600 hover:bg-cyan-700 text-white border border-cyan-500'
                    : 'text-cyan-200 border-cyan-600 hover:bg-cyan-900 hover:text-cyan-100'
                }`}
              >
                ðŸŽ¯ Typing Test
              </Button>
              <Button
                onClick={() => setCurrentView('analytics')}
                variant={currentView === 'analytics' ? 'default' : 'outline'}
                className={`btn-hover btn-active transition-all duration-200 ${
                  currentView === 'analytics'
                    ? 'bg-cyan-600 hover:bg-cyan-700 text-white border border-cyan-500'
                    : 'text-cyan-200 border-cyan-600 hover:bg-cyan-900 hover:text-cyan-100'
                }`}
              >
                ðŸ“Š Analytics
              </Button>
            </div>
          </div>

          {currentView === 'analytics' ? (
            <AnalyticsDashboard />
          ) : (
            <>
                                     {!isTestActive ? (
                       /* Test Configuration */
                       <div className="space-y-6">
                         <div className="card-entrance">
                           <TestConfig settings={testSettings} onSettingsChange={setTestSettings} />
                         </div>
                         <div className="text-center bounce-in">
                           <Button
                             onClick={startTest}
                             className="bg-cyan-600 hover:bg-cyan-700 text-white border border-cyan-500 shadow-lg shadow-cyan-500/25 px-8 py-3 text-lg btn-hover btn-active"
                             size="lg"
                           >
                             Start Test
                           </Button>
                         </div>
                       </div>
                    ) : (
              /* Active Test */
              <div className="space-y-6 fade-in">
              {/* Timer - Only show for time mode or custom mode with time limit, hide in words mode and zen mode */}
              {(testSettings.mode === 'time' || (testSettings.mode === 'custom' && testSettings.customUseTime)) && !words_modeActive && (
                <Card className="bg-gray-900 border border-cyan-600 shadow-lg shadow-cyan-500/25 sticky top-0 z-10 md:top-0 top-4">
                  <CardContent className="p-4">
                    <div className="flex items-center justify-between">
                      <h2 className="text-lg font-semibold text-cyan-100">
                        {isCountingDown ? 'Get Ready!' : 'Time Remaining'}
                      </h2>
                      <div className="text-xl font-bold text-green-100">
                        {isCountingDown ? (
                          <span className="text-2xl text-cyan-400 animate-pulse">{countdown}</span>
                        ) : (
                          `${Math.floor(timeRemaining / 60).toString().padStart(2, '0')}:${(timeRemaining % 60).toString().padStart(2, '0')}`
                        )}
                      </div>
                    </div>
                    
                    {/* Progress bar */}
                    {!isCountingDown && (
                      <div className="w-full bg-gray-800 rounded-full h-2 mt-3">
                        <div 
                          className="bg-gradient-to-r from-cyan-500 to-green-500 h-2 rounded-full transition-all duration-1000 ease-linear shadow-lg shadow-cyan-500/50"
                          style={{ 
                            width: `${(() => {
                              const totalTime = testSettings.mode === 'custom' ? (testSettings.customTimeLimit || 30) : testSettings.duration;
                              return ((totalTime - timeRemaining) / totalTime) * 100;
                            })()}%` 
                          }}
                        />
                      </div>
                    )}
                  </CardContent>
                </Card>
              )}
              
              {/* Spacer for sticky timer - only when timer is active */}
              {(testSettings.mode === 'time' || (testSettings.mode === 'custom' && testSettings.customUseTime)) && !words_modeActive && (
                <div className="h-16 md:h-20"></div>
              )}
              
              {/* Word Counter - Only show for words mode or custom mode with word limit */}
              {words_modeActive && (
                <Card className="bg-gray-900 border border-cyan-600 shadow-lg shadow-cyan-500/25 slide-up">
                  <CardContent className="p-6">
                    <div className="flex items-center justify-between">
                      <h2 className="text-xl font-semibold text-cyan-100">Words</h2>
                      <div className="text-2xl font-bold text-green-100">
                        {words_completedCount} / {words_targetTokens.length}
                      </div>
                    </div>
                    
                    {/* Progress bar */}
                    <div className="w-full bg-gray-800 rounded-full h-2 mt-4">
                      <div 
                        className="bg-gradient-to-r from-cyan-500 to-green-500 h-2 rounded-full transition-all duration-300 ease-linear shadow-lg shadow-cyan-500/50"
                        style={{ 
                          width: `${(words_completedCount / words_targetTokens.length) * 100}%` 
                        }}
                      />
                    </div>
                  </CardContent>
                </Card>
              )}
              
              {/* Typing Area */}
              <TypingArea
                expectedText={expectedText}
                currentPosition={currentPosition}
                characterStatus={characterStatus}
                typedCharacters={typedCharacters}
                onKeyDown={handleKeyDown}
                isActive={isTestActive}
                quoteAuthor={testSettings.mode === 'quote' ? quoteAuthor : undefined}
                liveWPM={testSettings.mode === 'zen' ? liveWPM : undefined}
                isZenMode={testSettings.mode === 'zen'}
                zenContent={zenContent}
                onZenContentChange={handleZenContentChange}
                onEndTest={testSettings.mode === 'zen' ? endTest : undefined}
              />
              
              {/* Manual End Button - Show for Words, Quote, and Custom modes (Zen has its own toolbar) */}
              {(testSettings.mode === 'words' || testSettings.mode === 'quote' || testSettings.mode === 'custom') && (
                <div className="text-center fade-in">
                  <Button 
                    variant="outline" 
                    onClick={endTest}
                    className="text-cyan-200 border-cyan-600 hover:bg-cyan-900 hover:text-cyan-100 btn-hover btn-active"
                  >
                    End Test
                  </Button>
                </div>
              )}
            </div>
          )}
          
          {/* Results */}
          {showResults && (() => {
            console.log("ðŸŽ¯ Rendering results with data:", {
              finalWPM: finalWPM || 0,
              finalAccuracy: finalAccuracy || 0,
              backspaces: backspaces || 0,
              analytics_wpmTimeline: analytics_wpmTimeline || [],
              behavioralMetrics: behavioralMetrics || {},
              typingPersona: typingPersona || null,
              personaInsights: personaInsights || []
            });
            return (
            <div className="bg-gray-900 p-6 rounded-lg border border-cyan-600 shadow-lg shadow-cyan-500/25 card-entrance">
              <div className="max-w-4xl mx-auto">
                <h2 className="text-3xl font-bold text-cyan-100 mb-6 text-center fade-in">Test Results</h2>
                
                {/* Main Stats */}
                <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
                  <div className="bg-gray-800 p-6 rounded-lg border border-cyan-600 shadow-sm text-center card-entrance stagger-1">
                    <div className="text-4xl font-bold text-cyan-100 mb-2">
                      {finalWPM || 0}
                    </div>
                    <div className="text-cyan-200 uppercase tracking-wide text-sm font-medium">Words Per Minute</div>
                  </div>
                  
                  <div className="bg-gray-800 p-6 rounded-lg border border-cyan-600 shadow-sm text-center card-entrance stagger-2">
                    <div className="text-4xl font-bold text-cyan-100 mb-2">
                      {(finalAccuracy || 0).toFixed(1)}%
                    </div>
                    <div className="text-cyan-200 uppercase tracking-wide text-sm font-medium">Accuracy</div>
                  </div>
                  
                  <div className="bg-gray-800 p-6 rounded-lg border border-cyan-600 shadow-sm text-center card-entrance stagger-3">
                    <div className="text-4xl font-bold text-cyan-100 mb-2">
                      {backspaces || 0}
                    </div>
                    <div className="text-cyan-200 uppercase tracking-wide text-sm font-medium">Backspaces</div>
                  </div>
                </div>

                {/* Results Summary */}
                <div className="bg-gradient-to-r from-gray-800 to-gray-700 p-6 rounded-lg border border-cyan-600 shadow-sm mb-6 card-entrance stagger-4">
                  <h3 className="text-xl font-semibold text-cyan-100 mb-4 text-center">ðŸ“Š Performance Summary</h3>
                  <p className="text-cyan-100 leading-relaxed text-lg text-center">
                    {generateResultsSummary({
                      wpm: finalWPM || 0,
                      accuracy: finalAccuracy || 0,
                      backspaces: backspaces || 0,
                      wpmOverTime: analytics_wpmTimeline?.map(item => item.wpm) || [],
                      consistencyScore: behavioralMetrics?.typingConsistencyScore || 50,
                      fatigueScore: behavioralMetrics?.fatigueScore || 0,
                      reactionDelay: behavioralMetrics?.reactionDelay || 0
                    })}
                  </p>
                </div>

                {/* Typing Persona */}
                {typingPersona && (
                  <div className="bg-gradient-to-r from-gray-800 to-gray-700 p-6 rounded-lg border-2 border-cyan-600 shadow-lg mb-6 card-entrance stagger-5">
                    <div className="text-center mb-4">
                      <div className="text-6xl mb-2 bounce-in">{typingPersona.icon}</div>
                      <h3 className="text-2xl font-bold text-cyan-100 mb-2 fade-in">{typingPersona.title}</h3>
                      <p className="text-cyan-100 text-lg leading-relaxed max-w-2xl mx-auto fade-in stagger-1">
                        {typingPersona.description}
                      </p>
                    </div>
                    
                    {/* Persona Traits */}
                    <div className="flex flex-wrap justify-center gap-2 mb-4">
                      {typingPersona.traits.map((trait, index) => (
                        <span 
                          key={index}
                          className="px-3 py-1 bg-gray-700 bg-opacity-70 rounded-full text-sm font-medium text-cyan-100 border border-cyan-600 fade-in"
                          style={{ animationDelay: `${0.6 + index * 0.1}s` }}
                        >
                          {trait}
                        </span>
                      ))}
                    </div>
                    
                    {/* Persona Insights */}
                    {personaInsights.length > 0 && (
                      <div className="bg-gray-700 bg-opacity-50 rounded-lg p-4">
                        <h4 className="text-lg font-semibold text-cyan-100 mb-3 text-center">ðŸ’¡ Insights for You</h4>
                        <ul className="space-y-2">
                          {personaInsights.map((insight, index) => (
                            <li key={index} className="flex items-start">
                              <span className="text-cyan-400 mr-2">â€¢</span>
                              <span className="text-cyan-100">{insight}</span>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                )}



                {/* Behavioral Metrics */}
                <div className="bg-gradient-to-r from-gray-800 to-gray-700 p-6 rounded-lg border border-cyan-600 shadow-sm mb-6">
                  <h3 className="text-xl font-semibold text-cyan-100 mb-4 text-center">ðŸŽ¯ Behavioral Analysis</h3>
                  <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 max-w-4xl mx-auto">
                    {/* Consistency Score */}
                    <div className="text-center p-6 bg-gray-700 bg-opacity-70 rounded-lg border border-cyan-600 shadow-sm hover:shadow-md transition-shadow">
                      <div className="text-3xl font-bold text-cyan-100 mb-2">
                        {isNaN(behavioralMetrics?.typingConsistencyScore) ? '50' : Math.round(behavioralMetrics?.typingConsistencyScore || 50)}
                      </div>
                      <div className="text-sm text-cyan-200 font-medium mb-2">Consistency Score</div>
                      <div className="text-xs text-cyan-300">
                        {(behavioralMetrics?.typingConsistencyScore || 50) >= 80 ? 'ðŸŒŸ Excellent' : 
                         (behavioralMetrics?.typingConsistencyScore || 50) >= 60 ? 'âœ¨ Good' : 
                         (behavioralMetrics?.typingConsistencyScore || 50) >= 40 ? 'ðŸ‘ Fair' : 'ðŸ’ª Keep Practicing'}
                      </div>
                    </div>

                    {/* Reaction Delay */}
                    <div className="text-center p-6 bg-gray-700 bg-opacity-70 rounded-lg border border-cyan-600 shadow-sm hover:shadow-md transition-shadow">
                      <div className="text-3xl font-bold text-cyan-100 mb-2">
                        {(behavioralMetrics?.reactionDelay || 0).toFixed(2)}s
                      </div>
                      <div className="text-sm text-cyan-200 font-medium mb-2">Reaction Delay</div>
                      <div className="text-xs text-cyan-300">
                        {(behavioralMetrics?.reactionDelay || 0) <= 1 ? 'ðŸš€ Quick Start' : 
                         (behavioralMetrics?.reactionDelay || 0) <= 3 ? 'âœ¨ Normal' : 'â³ Slow Start'}
                      </div>
                    </div>

                    {/* Peak Error Second */}
                    <div className="text-center p-6 bg-gray-700 bg-opacity-70 rounded-lg border border-cyan-600 shadow-sm hover:shadow-md transition-shadow">
                      <div className="text-3xl font-bold text-cyan-100 mb-2">
                        {peakErrorSecond}
                      </div>
                      <div className="text-sm text-cyan-200 font-medium mb-2">Peak Error Second</div>
                      <div className="text-xs text-cyan-300">
                        {peakErrorSecond === 'N/A' ? 'âœ¨ No errors detected' : 'âš ï¸ Most errors occurred'}
                      </div>
                    </div>

                    {/* Peak Correction Second */}
                    <div className="text-center p-6 bg-gray-700 bg-opacity-70 rounded-lg border border-cyan-600 shadow-sm hover:shadow-md transition-shadow">
                      <div className="text-3xl font-bold text-cyan-100 mb-2">
                        {peakCorrectionSecond}
                      </div>
                      <div className="text-sm text-cyan-200 font-medium mb-2">Peak Correction Second</div>
                      <div className="text-xs text-cyan-300">
                        {peakCorrectionSecond === 'N/A' ? 'âœ¨ No corrections needed' : 'âŒ« Most corrections made'}
                      </div>
                    </div>
                  </div>

                  {/* Error & Correction Analysis */}
                  <ErrorAnalysis 
                    errorHotspots={behavioralMetrics?.topErrorHotspots || []}
                    backspaceHotspots={behavioralMetrics?.topBackspaceHotspots || []}
                    testDuration={testSettings.duration}
                    totalErrors={(totalTypedCharacters || 0) - (correctCharacters || 0)}
                    totalBackspaces={backspaces || 0}
                  />
                </div>

                {/* Behavioral Insights */}
                <BehavioralInsights
                  currentSession={getCurrentSessionData(
                    finalWPM || 0,
                    finalAccuracy || 0,
                    backspaces || 0,
                    behavioralMetrics,
                    missedCharacters || {},
                    analytics_wpmTimeline || [],
                    testSettings.duration
                  )}
                  historicalData={calculateHistoricalAverages()}
                />

                {/* WPM Prediction */}
                <WPMPrediction />

                {/* Export Buttons */}
                <div className="bg-gray-800 p-6 rounded-lg border border-cyan-600 shadow-sm mb-6">
                  <h3 className="text-xl font-semibold text-cyan-100 mb-4 text-center">Export Session Data</h3>
                  <div className="flex flex-col sm:flex-row gap-3 justify-center">
                    <Button 
                      onClick={() => exportToCSV({
                        finalWPM: finalWPM || 0,
                        accuracy: finalAccuracy || 0,
                        totalBackspaces: backspaces || 0,
                        testDuration: testSettings.duration,
                        textType: testSettings.textType,
                        totalCharacters: totalTypedCharacters || 0,
                        correctCharacters: correctCharacters || 0,
                        incorrectCharacters: (totalTypedCharacters || 0) - (correctCharacters || 0),
                        wpmOverTime: analytics_wpmTimeline?.map(item => item.wpm) || [],
                        charactersPerSecond: [],
                        commonlyMistypedCharacters: missedCharacters || {},
                        testStartTime: testStartTime || Date.now(),
                        testEndTime: Date.now(),
                        typingConsistencyScore: behavioralMetrics?.typingConsistencyScore || 50,
                        fatigueScore: 0, // Removed fatigue score
                        reactionDelay: behavioralMetrics?.reactionDelay || 0,
                        topErrorHotspots: behavioralMetrics?.topErrorHotspots || [],
                        topBackspaceHotspots: behavioralMetrics?.topBackspaceHotspots || [],
                        typingPersona: typingPersona || { name: '', title: '', description: '', icon: '', color: '', traits: [] },
                        personaInsights: personaInsights || [],
                        keystrokeLog: keystrokeLog || []
                      })}
                      variant="outline"
                      className="border-cyan-500 text-cyan-200 hover:bg-cyan-900 hover:text-cyan-100"
                    >
                      ðŸ“Š Export as CSV
                    </Button>
                    <Button 
                      onClick={() => exportToJSON({
                        finalWPM: finalWPM || 0,
                        accuracy: finalAccuracy || 0,
                        totalBackspaces: backspaces || 0,
                        testDuration: testSettings.duration,
                        textType: testSettings.textType,
                        totalCharacters: totalTypedCharacters || 0,
                        correctCharacters: correctCharacters || 0,
                        incorrectCharacters: (totalTypedCharacters || 0) - (correctCharacters || 0),
                        wpmOverTime: analytics_wpmTimeline?.map(item => item.wpm) || [],
                        charactersPerSecond: [],
                        commonlyMistypedCharacters: missedCharacters || {},
                        testStartTime: testStartTime || Date.now(),
                        testEndTime: Date.now(),
                        typingConsistencyScore: behavioralMetrics?.typingConsistencyScore || 50,
                        fatigueScore: 0, // Removed fatigue score
                        reactionDelay: behavioralMetrics?.reactionDelay || 0,
                        topErrorHotspots: behavioralMetrics?.topErrorHotspots || [],
                        topBackspaceHotspots: behavioralMetrics?.topBackspaceHotspots || [],
                        typingPersona: typingPersona || { name: '', title: '', description: '', icon: '', color: '', traits: [] },
                        personaInsights: personaInsights || [],
                        keystrokeLog: keystrokeLog || []
                      })}
                      variant="outline"
                      className="border-cyan-500 text-cyan-200 hover:bg-cyan-900 hover:text-cyan-100"
                    >
                      ðŸ“„ Export as JSON
                    </Button>
                  </div>
                </div>

                <div className="text-center">
                  <Button onClick={() => window.location.reload()} className="bg-cyan-600 text-white px-6 py-2 rounded-md hover:bg-cyan-700 transition-colors border border-cyan-500 shadow-lg shadow-cyan-500/25">
                    Take Another Test
                  </Button>
                </div>
              </div>
            </div>
          );
          })()}

          {/* Session History */}
          <div className="mt-8">
            <SessionHistory 
              onSessionSelect={displayHistoricalResults}
              selectedSessionId={selectedSession?.id || null}
            />
          </div>
            </>
          )}
        </div>
      </div>
    </div>
  );
};